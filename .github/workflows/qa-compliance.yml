# Copyright (c) 2021-2025 TiaC Systems
# SPDX-License-Identifier: Apache-2.0

name: QA Compliance Check

on:
  workflow_dispatch: # And manually on button click
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  qa-compliance:
    name: Run compliance checks on patch series (PR)
    runs-on: ubuntu-24.04
    env:
      BASE_REF: ${{ github.base_ref }}
      HEAD_REF: ${{ github.head_ref }}
    defaults:
      run:
        shell: bash

    steps:
      - name: Apply container HTTP/2 framing layer workaround
        run: |
          # FIXME: For unknown reasons, the local development host and CI is
          #        running in temporary "Error in the HTTP2 framing layer".
          #        Forcing the historical but still supported HTTP/1.1 layer
          #        seems to be a stable workaround - happened in Oct. 2023.
          git config --global --add http.version HTTP/1.1

      - name: Update GitHub PATH for west
        run: |
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Checkout the code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          show-progress: true
          path: workspace/bridle
          ref: ${{ github.event.pull_request.head.sha }}

      - id: history
        name: Ensure linear history in PR
        working-directory: workspace/bridle
        run: |
          # Ensure BASE_REF is set
          if [[ -z "${BASE_REF}" ]]; then
            echo "::error ::BASE_REF is empty (github.base_ref not set)"
            exit 1
          fi
          echo "BASE_REF='${BASE_REF}'"

          # Ensure we have origin/${BASE_REF} locally
          git remote -v

          # Fetch the base branch explicitly (safe even if it already exists)
          git fetch origin "${BASE_REF}" --quiet || \
            (echo "::error ::Failed to fetch 'origin/${BASE_REF}'"; exit 1)

          # Ensure HEAD_REF is set
          if [[ -z "${HEAD_REF}" ]]; then
            echo "::error ::HEAD_REF is empty (github.head_ref not set)"
            exit 1
          fi
          echo "HEAD_REF='${HEAD_REF}'"

          # Ensure we have origin/${HEAD_REF} locally
          git remote -v

          # Fetch the head branch explicitly (safe even if it already exists)
          git fetch origin "${HEAD_REF}" --quiet || \
            (echo "::error ::Failed to fetch 'origin/${HEAD_REF}'"; exit 1)

          # Count merge commits reachable from the PR but not from base
          merge_count=$(git rev-list --merges --count "origin/${BASE_REF}..origin/${HEAD_REF}" 2>/dev/null || echo "ERR")
          if [[ "${merge_count}" == "ERR" ]]; then
            echo "::error ::git rev-list failed; ensure 'origin/${BASE_REF}' and 'origin/${HEAD_REF}' exists"
            exit 1
          fi
          if ! [[ "${merge_count}" =~ ^[0-9]+$ ]]; then
            echo "::error ::Unexpected rev-list output: ${merge_count}"
            exit 1
          fi
          if [[ "${merge_count}" -ne 0 ]]; then
            echo "::error ::Merge commits not allowed, rebase instead"
            exit 1
          fi

          # Rebase onto origin/${BASE_REF}
          git rebase "origin/${BASE_REF}" || \
            (echo "::error ::Rebase failed; resolve conflicts then push"; exit 1)

          # Show some history
          git log --pretty=oneline --decorate --max-count=10

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          working-directory: workspace
          enable-cache: true

      - name: Create and enter Python 3.12 virtual environment
        working-directory: workspace
        run: |
          uv venv --python 3.12
          source .venv/bin/activate
          echo "$PATH" > $GITHUB_PATH

      - name: Install base dependencies
        working-directory: workspace
        run: |
          which python3 && python3 --version
          which uv && uv --version
          uv pip install --upgrade --requirement bridle/zephyr/requirements-base.txt
          uv pip show --files west
          which west && west --version

      - name: West init and update
        working-directory: workspace
        run: |
          west init --local bridle
          west update --fetch=always --stats
          west zephyr-export
          west bridle-export

      - name: Install compliance dependencies
        working-directory: workspace
        run: |
          uv pip install --upgrade --requirement zephyr/scripts/requirements-compliance.txt
          uv pip install --upgrade --requirement zephyr/scripts/requirements-actions.in

      - id: compliance
        name: Run compliance tests
        working-directory: workspace/bridle
        run: |
          # Ensure BRIDLE_BASE is an Git folder
          export BRIDLE_BASE="$(pwd)"
          if [[ -z "${BRIDLE_BASE}" || ! -d "${BRIDLE_BASE}" ]]; then
            echo "::error ::BRIDLE_BASE is empty or not a folder"
            exit 1
          fi
          git -C "${BRIDLE_BASE}" remote -v
          echo "BRIDLE_BASE='${BRIDLE_BASE}'"

          # Ensure ZEPHYR_BASE is an Git folder
          export ZEPHYR_BASE="$(dirname "$(pwd)")/zephyr"
          if [[ -z "${ZEPHYR_BASE}" || ! -d "${ZEPHYR_BASE}" ]]; then
            echo "::error ::ZEPHYR_BASE is empty or not a folder"
            exit 1
          fi
          git -C "${ZEPHYR_BASE}" remote -v
          echo "ZEPHYR_BASE='${ZEPHYR_BASE}'"

          # Show some history
          echo "Bridle latest history:"
          git -C "${BRIDLE_BASE}" log --pretty=oneline --decorate --max-count=20
          echo "Zephyr latest history:"
          git -C "${ZEPHYR_BASE}" log --pretty=oneline --decorate --max-count=20

          # Check compliance
          # -m Kconfig \
          # -m SysbuildKconfig \
          ${BRIDLE_BASE}/scripts/ci/check_compliance.py \
            --annotate \
            -m BinaryFiles \
            -m BoardYml \
            -m Checkpatch \
            -m ClangFormat \
            -m DevicetreeBindings \
            -m GitDiffCheck \
            -m Gitlint \
            -m Identity \
            -m ImageSize \
            -m KconfigBasic \
            -m KconfigBasicNoModules \
            -m KconfigHWMv2 \
            -m KeepSorted \
            -m MaintainersFormat \
            -m ModulesMaintainers \
            -m Nits \
            -m Pylint \
            -m Ruff \
            -m SphinxLint \
            -m SysbuildKconfigBasic \
            -m SysbuildKconfigBasicNoModules \
            -m TextEncoding \
            -m YAMLLint \
            -c "origin/${BASE_REF}..origin/${HEAD_REF}"

      - name: Upload compliance tests results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compliance.xml
          path: workspace/bridle/compliance.xml

      - name: Convert compliance test reports to annotations
        if: always()
        uses: mikepenz/action-junit-report@v5
        with:
          check_name: compliance-report (bridle)
          report_paths: "**/bridle/compliance.xml"
          require_tests: true
          fail_on_failure: false

      - id: check
        name: Check warnings
        if: always()
        working-directory: workspace/bridle
        run: |
          # Ensure there is an compliance check result file
          if [[ ! -s "compliance.xml" ]]; then
            echo "::error ::compliance.xml file is empty or missed"
            exit 1;
          fi

          # Parse sub-result files
          rc=0
          #       Checkpatch.txt \
          #       Kconfig.txt \
          for file in \
                  Nits.txt \
                  Identity.txt \
                  GitDiffCheck.txt \
                  Gitlint.txt \
                  Pylint.txt \
                  YAMLLint.txt \
                  MaintainersFormat.txt \
                  ModulesMaintainers.txt \
                  DevicetreeBindings.txt \
                  KconfigBasicNoModules.txt \
                  KconfigBasic.txt \
                  KeepSorted.txt \
                  ImageSize.txt \
                  BinaryFiles.txt \
              ; do
            if [[ -s "${file}" ]]; then
              errors=$(cat "${file}")
              errors="${errors//'%'/'%25'}"
              errors="${errors//$'\n'/'%0A'}"
              errors="${errors//$'\r'/'%0D'}"
              echo "::error file=${file}::${errors}"
              rc=1
            fi
          done

          # Final fail
          if [[ "${rc}" -ne 0 ]]; then
            exit 1
          fi
